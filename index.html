<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
<title>Experiments with HTTP/2 server
</title>
<link type='text/css' href='style.css' rel='stylesheet'>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width">
   <script src="jquery.min.js"></script>
<script src="toc.min.js"></script>
<script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [['$','$']],
         processEscapes: true
       }
     });
   </script>
   <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
   </script>
   
</head>
<body>
<div id="content-container">
<div id="toc">
<div id="page-toc">
</div>
<div id="toc-footer"><ul><li><a href="https://github.com/melisgl/mgl-pax">[generated by MGL-PAX]</a></li></ul></div>
</div>
<div id="content">
<p><a id="x-28MINI-HTTP2-3A-40INDEX-20MGL-PAX-3ASECTION-29"></a>
<a id="MINI-HTTP2:@INDEX%20MGL-PAX:SECTION"></a></p>
<p><span class="outer-navigation"><span class="navigation"> <a href="#MINI-HTTP2:@SERVER-ACTIONS%20MGL-PAX:SECTION" title="Serving HTTP/2">&#8594;</a> <a href="index.html" title="Experiments with HTTP/2 server">&#8634;</a></span></span></p>
<h1><a href="index.html">Experiments with HTTP/2 server</a></h1>
<h2>Table of Contents</h2>
<ul>
<li><a href="#MINI-HTTP2:@SERVER-ACTIONS%20MGL-PAX:SECTION" title="Serving HTTP/2">1 Serving HTTP/2</a></li>
<li><a href="#MINI-HTTP2:@SYNCHRONOUS%20MGL-PAX:SECTION" title="Synchronous implementation">2 Synchronous implementation</a></li>
<li><a href="#MINI-HTTP2:@USE-HTTP2-LIB%20MGL-PAX:SECTION" title="Server built using HTTP2 package.">3 Server built using HTTP2 package.</a></li>
<li><a href="#TLS-SERVER%2FASYNC:@ASYNC%20MGL-PAX:SECTION" title="CL-ASYNC based implementation (asynchronous)">4 CL-ASYNC based implementation (asynchronous)</a></li>
<li><a href="#MINI-HTTP2:@HTTP2-PROTOCOL%20MGL-PAX:SECTION" title="HTTP/2 protocol.">5 HTTP/2 protocol.</a></li>
</ul>
<h6>[in package MINI-HTTP2]</h6>
<p>I wanted to play with different options for HTTP/2 server implementations. While
I have a more correct implementation of HTTP/2, I wanted something
simple to test different client handling options, as well as speed limits and impact of different choices.</p>
<p>So this repository implements:</p>
<ul>
<li><p>very simplified (and indeed incorrect in few ways) but server side of HTTP/2 protocol, and based of that</p></li>
<li><p>several versions of TCP server that accept and handle the request.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3A-40SERVER-ACTIONS-20MGL-PAX-3ASECTION-29"></a>
<a id="MINI-HTTP2:@SERVER-ACTIONS%20MGL-PAX:SECTION"></a></p>
<p><span class="outer-navigation"><span class="navigation"> <a href="index.html" title="Experiments with HTTP/2 server">&#8592;</a> <a href="index.html" title="Experiments with HTTP/2 server">&#8593;</a> <a href="#MINI-HTTP2:@SYNCHRONOUS%20MGL-PAX:SECTION" title="Synchronous implementation">&#8594;</a> <a href="#MINI-HTTP2:@SERVER-ACTIONS%20MGL-PAX:SECTION" title="Serving HTTP/2">&#8634;</a></span></span></p>
<h2><a href="#MINI-HTTP2:@SERVER-ACTIONS%20MGL-PAX:SECTION">1 Serving HTTP/2</a></h2>
<p>This framework is used by all server implementation:</p>
<p><a id="x-28MINI-HTTP2-3ACREATE-SERVER-20FUNCTION-29"></a>
<a id="MINI-HTTP2:CREATE-SERVER%20FUNCTION"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:CREATE-SERVER%20FUNCTION" >CREATE-SERVER</a></span></span> <span class="locative-args">PORT TLS DISPATCH-METHOD &amp;KEY (HOST &quot;127.0.0.1&quot;) (ANNOUNCE-URL-CALLBACK (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_cons_1.htm" title="CONSTANTLY (MGL-PAX:CLHS FUNCTION)"><code>CONSTANTLY</code></a> <code>NIL</code>))</span></span></p>

<p>Create a server on <code>HOST</code> and <code>PORT</code> that handles connections (possibly with <code>TLS</code>) using
<code>DISPATCH-METHOD</code>.</p>

<p><code>ANNOUNCE-URL-CALLBACK</code> is called when server is set up and receives one
parameter, URL server listens to. The idea is to be able to connect to server
when <code>PORT</code> is 0, that is, random port.</p>

<p>Calls <a href="#MINI-HTTP2:DO-NEW-CONNECTION%20GENERIC-FUNCTION" title="MINI-HTTP2:DO-NEW-CONNECTION GENERIC-FUNCTION"><code>DO-NEW-CONNECTION</code></a> to handle the connections with restart <a href="#MINI-HTTP2:KILL-SERVER%20RESTART" title="MINI-HTTP2:KILL-SERVER RESTART"><code>KILL-SERVER</code></a> available.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3ADO-NEW-CONNECTION-20GENERIC-FUNCTION-29"></a>
<a id="MINI-HTTP2:DO-NEW-CONNECTION%20GENERIC-FUNCTION"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[generic-function]</span> <span class="reference-object"><a href="#MINI-HTTP2:DO-NEW-CONNECTION%20GENERIC-FUNCTION" >DO-NEW-CONNECTION</a></span></span> <span class="locative-args">LISTENING-SOCKET TLS DISPATCH-METHOD</span></span></p>

<p>This method is implemented for the separate connection types. It waits on
new (possibly tls) connection to the <code>LISTENING-SOCKET</code> and start handling it
using <code>DISPATCH-METHOD</code>.</p>

<p><code>DISPATCH-METHOD</code> can presently be either <code>:NONE</code>, <code>:NONE/HTTP2</code>, <code>:THREAD</code> or
<code>:ASYNC</code> (w/o <code>TLS</code> only for now), see appropritate methods. Methods can be created
for new dispatch methods.</p>

<p><code>TLS</code> is either <code>NIL</code> or <code>:TLS</code>. Note that when using HTTP/2 without <code>TLS</code>, most clients have to be instructed to
use tls - e.g., --http2-prior-knowledge for curl.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3AKILL-SERVER-20RESTART-29"></a>
<a id="MINI-HTTP2:KILL-SERVER%20RESTART"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[restart]</span> <span class="reference-object"><a href="#MINI-HTTP2:KILL-SERVER%20RESTART" >KILL-SERVER</a></span></span> <span class="locative-args">&amp;OPTIONAL VALUE</span></span></p>

<p>Restart established in <a href="#MINI-HTTP2:CREATE-SERVER%20FUNCTION" title="MINI-HTTP2:CREATE-SERVER FUNCTION"><code>CREATE-SERVER</code></a> that can be invoked to terminate the server
properly and return <code>VALUE</code>.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3A-40SYNCHRONOUS-20MGL-PAX-3ASECTION-29"></a>
<a id="MINI-HTTP2:@SYNCHRONOUS%20MGL-PAX:SECTION"></a></p>
<p><span class="outer-navigation"><span class="navigation"> <a href="#MINI-HTTP2:@SERVER-ACTIONS%20MGL-PAX:SECTION" title="Serving HTTP/2">&#8592;</a> <a href="index.html" title="Experiments with HTTP/2 server">&#8593;</a> <a href="#MINI-HTTP2:@USE-HTTP2-LIB%20MGL-PAX:SECTION" title="Server built using HTTP2 package.">&#8594;</a> <a href="#MINI-HTTP2:@SYNCHRONOUS%20MGL-PAX:SECTION" title="Synchronous implementation">&#8634;</a></span></span></p>
<h2><a href="#MINI-HTTP2:@SYNCHRONOUS%20MGL-PAX:SECTION">2 Synchronous implementation</a></h2>
<p><a id="x-28MINI-HTTP2-3ADO-NEW-CONNECTION-20-28METHOD-20NIL-20-28T-20T-20-28EQL-20-3ANONE-29-29-29-29"></a>
<a id="MINI-HTTP2:DO-NEW-CONNECTION%20%28METHOD%20NIL%20%28T%20T%20%28EQL%20:NONE%29%29%29"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[method]</span> <span class="reference-object"><a href="#MINI-HTTP2:DO-NEW-CONNECTION%20%28METHOD%20NIL%20%28T%20T%20%28EQL%20:NONE%29%29%29" >DO-NEW-CONNECTION</a></span></span> <span class="locative-args">LISTENING-SOCKET TLS (DISPATCH-METHOD (<code>EQL</code>(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_eql.htm" title="EQL (MGL-PAX:CLHS FUNCTION)"><code>0</code></a> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_eql.htm" title="EQL (MGL-PAX:CLHS TYPE)"><code>1</code></a>) <code>:NONE</code>))</span></span></p>

<p>Handle the connection while doing nothing else.</p>

<p>This version (<code>DISPATCH-METHOD</code> being :none) gives up on trying to serve more
clients: when it gets connection, it reads the requests and handles them as they
arrive. When the client sends go-away frame, it closes connection and is ready
to serve another client.</p>

<p>Obviously, there is little overhead and this version is pretty fast, especially
with requet pilelining.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3ADO-NEW-CONNECTION-20-28METHOD-20NIL-20-28T-20T-20-28EQL-20-3ATHREAD-29-29-29-29"></a>
<a id="MINI-HTTP2:DO-NEW-CONNECTION%20%28METHOD%20NIL%20%28T%20T%20%28EQL%20:THREAD%29%29%29"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[method]</span> <span class="reference-object"><a href="#MINI-HTTP2:DO-NEW-CONNECTION%20%28METHOD%20NIL%20%28T%20T%20%28EQL%20:THREAD%29%29%29" >DO-NEW-CONNECTION</a></span></span> <span class="locative-args">LISTENING-SOCKET TLS (DISPATCH-METHOD (<code>EQL</code>(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_eql.htm" title="EQL (MGL-PAX:CLHS FUNCTION)"><code>0</code></a> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_eql.htm" title="EQL (MGL-PAX:CLHS TYPE)"><code>1</code></a>) <code>:THREAD</code>))</span></span></p>

<p>Handle the connection in a new thread.</p>

<p>This version (<code>DISPATCH-METHOD</code> being :thread) has supposedly disadvantage when
there are too many clients/threads (RAM for threads needed, .</p>

<p>The speed for single client is comparable to the single-client version.</p>

<p>Also, this version (as well as the single client one) can be ported to most CL
implementations, as it uses standard libraries - bordeaux-threads and usocket.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3ADO-CONNECTION-20FUNCTION-29"></a>
<a id="MINI-HTTP2:DO-CONNECTION%20FUNCTION"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:DO-CONNECTION%20FUNCTION" >DO-CONNECTION</a></span></span> <span class="locative-args">STREAM</span></span></p>

<p>Process a HTTP2 connection naively: handle preface, and read frames till there
  is end of stream; write static response in that case.</p>

<p>Terminate if either <code>SSL</code> error occurs, or go-away restart is invoked.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3A-2ABUFFER-2A-20VARIABLE-29"></a>
<a id="MINI-HTTP2:*BUFFER*%20VARIABLE"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[variable]</span> <span class="reference-object"><a href="#MINI-HTTP2:*BUFFER*%20VARIABLE" >*BUFFER*</a></span></span> <span class="locative-args">NIL</span></span></p>

<p>Preallocated buffer for reading from stream. This is initialized for each
connection depending on the dispatch method.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3AREAD-CLIENT-PREFACE-20FUNCTION-29"></a>
<a id="MINI-HTTP2:READ-CLIENT-PREFACE%20FUNCTION"></a></p>
<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:READ-CLIENT-PREFACE%20FUNCTION" >READ-CLIENT-PREFACE</a></span></span> <span class="locative-args">STREAM</span></span></li>
</ul>
<p><a id="x-28MINI-HTTP2-3ASEND-RESPONSE-20FUNCTION-29"></a>
<a id="MINI-HTTP2:SEND-RESPONSE%20FUNCTION"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:SEND-RESPONSE%20FUNCTION" >SEND-RESPONSE</a></span></span> <span class="locative-args">STREAM STREAM-ID</span></span></p>

<p>Write response to the request with <code>STREAM-ID</code>.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3A-40USE-HTTP2-LIB-20MGL-PAX-3ASECTION-29"></a>
<a id="MINI-HTTP2:@USE-HTTP2-LIB%20MGL-PAX:SECTION"></a></p>
<p><span class="outer-navigation"><span class="navigation"> <a href="#MINI-HTTP2:@SYNCHRONOUS%20MGL-PAX:SECTION" title="Synchronous implementation">&#8592;</a> <a href="index.html" title="Experiments with HTTP/2 server">&#8593;</a> <a href="#TLS-SERVER%2FASYNC:@ASYNC%20MGL-PAX:SECTION" title="CL-ASYNC based implementation (asynchronous)">&#8594;</a> <a href="#MINI-HTTP2:@USE-HTTP2-LIB%20MGL-PAX:SECTION" title="Server built using HTTP2 package.">&#8634;</a></span></span></p>
<h2><a href="#MINI-HTTP2:@USE-HTTP2-LIB%20MGL-PAX:SECTION">3 Server built using HTTP2 package.</a></h2>
<p>Server implementations so far used the simplified HTTP/2 protocol described
<a href="#MINI-HTTP2:@HTTP2-PROTOCOL%20MGL-PAX:SECTION" title="HTTP/2 protocol.">above</a>. Now we do the same using
HTTP2, still synchronously to compare the ease of
implementation and speed.</p>
<p><a id="x-28MINI-HTTP2-3ADO-NEW-CONNECTION-20-28METHOD-20NIL-20-28T-20T-20-28EQL-20-3ANONE-2FHTTP2-29-29-29-29"></a>
<a id="MINI-HTTP2:DO-NEW-CONNECTION%20%28METHOD%20NIL%20%28T%20T%20%28EQL%20:NONE%2FHTTP2%29%29%29"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[method]</span> <span class="reference-object"><a href="#MINI-HTTP2:DO-NEW-CONNECTION%20%28METHOD%20NIL%20%28T%20T%20%28EQL%20:NONE%2FHTTP2%29%29%29" >DO-NEW-CONNECTION</a></span></span> <span class="locative-args">LISTENING-SOCKET TLS (DISPATCH-METHOD (<code>EQL</code>(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_eql.htm" title="EQL (MGL-PAX:CLHS FUNCTION)"><code>0</code></a> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_eql.htm" title="EQL (MGL-PAX:CLHS TYPE)"><code>1</code></a>) <code>:NONE/HTTP2</code>))</span></span></p>

<p>Handle the connection while doing nothing else using HTTP2 asdf library for actual work. Otherwise it is same as the <code>:NONE</code> method (i.e., serving a single client)</p></li>
</ul>
<p><a id="x-28TLS-SERVER-2FASYNC-3A-40ASYNC-20MGL-PAX-3ASECTION-29"></a>
<a id="TLS-SERVER%2FASYNC:@ASYNC%20MGL-PAX:SECTION"></a></p>
<p><span class="outer-navigation"><span class="navigation"> <a href="#MINI-HTTP2:@USE-HTTP2-LIB%20MGL-PAX:SECTION" title="Server built using HTTP2 package.">&#8592;</a> <a href="index.html" title="Experiments with HTTP/2 server">&#8593;</a> <a href="#MINI-HTTP2:@HTTP2-PROTOCOL%20MGL-PAX:SECTION" title="HTTP/2 protocol.">&#8594;</a> <a href="#TLS-SERVER%2FASYNC:@ASYNC%20MGL-PAX:SECTION" title="CL-ASYNC based implementation (asynchronous)">&#8634;</a></span></span></p>
<h2><a href="#TLS-SERVER%2FASYNC:@ASYNC%20MGL-PAX:SECTION">4 CL-ASYNC based implementation (asynchronous)</a></h2>
<h6>[in package TLS-SERVER/ASYNC]</h6>
<p><a id="x-28MINI-HTTP2-3ADO-NEW-CONNECTION-20-28METHOD-20NIL-20-28T-20-28EQL-20NIL-29-20-28EQL-20-3AASYNC-29-29-29-29"></a>
<a id="MINI-HTTP2:DO-NEW-CONNECTION%20%28METHOD%20NIL%20%28T%20%28EQL%20NIL%29%20%28EQL%20:ASYNC%29%29%29"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[method]</span> <span class="reference-object"><a href="#MINI-HTTP2:DO-NEW-CONNECTION%20%28METHOD%20NIL%20%28T%20%28EQL%20NIL%29%20%28EQL%20:ASYNC%29%29%29" >DO-NEW-CONNECTION</a></span></span> <span class="locative-args">SOCKET (TLS (<code>EQL</code>(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_eql.htm" title="EQL (MGL-PAX:CLHS FUNCTION)"><code>0</code></a> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_eql.htm" title="EQL (MGL-PAX:CLHS TYPE)"><code>1</code></a>) <code>NIL</code>)) (DISPATCH-METHOD (<code>EQL</code>(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_eql.htm" title="EQL (MGL-PAX:CLHS FUNCTION)"><code>0</code></a> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_eql.htm" title="EQL (MGL-PAX:CLHS TYPE)"><code>1</code></a>) <code>:ASYNC</code>))</span></span></p>

<p>Handle new connections using cl-async event loop.</p>

<p>Pros: This version can be run in one thread and process many clients.</p>

<p>Cons: requires a specific C library, and the implementation as-is depends on
SBCL internal function - we re-use the file descriptor of socket created by
usocket package, as otherwise access to the port of server is complicated.</p></li>
</ul>
<p><a id="x-28TLS-SERVER-2FASYNC-3ARUN-UV-SERVER-20FUNCTION-29"></a>
<a id="TLS-SERVER%2FASYNC:RUN-UV-SERVER%20FUNCTION"></a></p>
<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#TLS-SERVER%2FASYNC:RUN-UV-SERVER%20FUNCTION" >RUN-UV-SERVER</a></span></span> <span class="locative-args">&amp;KEY (PORT 2022)</span></span></li>
</ul>
<p><a id="x-28MINI-HTTP2-3A-40HTTP2-PROTOCOL-20MGL-PAX-3ASECTION-29"></a>
<a id="MINI-HTTP2:@HTTP2-PROTOCOL%20MGL-PAX:SECTION"></a></p>
<p><span class="outer-navigation"><span class="navigation"> <a href="#TLS-SERVER%2FASYNC:@ASYNC%20MGL-PAX:SECTION" title="CL-ASYNC based implementation (asynchronous)">&#8592;</a> <a href="index.html" title="Experiments with HTTP/2 server">&#8593;</a> <a href="#MINI-HTTP2:@HTTP2-PROTOCOL%20MGL-PAX:SECTION" title="HTTP/2 protocol.">&#8634;</a></span></span></p>
<h2><a href="#MINI-HTTP2:@HTTP2-PROTOCOL%20MGL-PAX:SECTION">5 HTTP/2 protocol.</a></h2>
<p>Simplified - and incorrect in many corner cases - HTTP/2 protocol implemented
here is is as follows. This should be sufficient to respond to a browser, curl
or h2load.</p>
<p><a id="x-28MINI-HTTP2-3A-2BCLIENT-PREFACE-START-2B-20VARIABLE-29"></a>
<a id="MINI-HTTP2:+CLIENT-PREFACE-START+%20VARIABLE"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[variable]</span> <span class="reference-object"><a href="#MINI-HTTP2:+CLIENT-PREFACE-START+%20VARIABLE" >+CLIENT-PREFACE-START+</a></span></span> <span class="locative-args">#(80 82 73 32 42 32 72 84 84 80 47 50 46 48 13 10 13 10 83 77 13 10 13 10)</span></span></p>

<p>Clients send 24 octets of <code>+CLIENT-PREFACE-START+</code>, which in hex
notation is this. That is, the connection preface starts with the string &quot;PRI *
 HTTP/2.0\r\n\r\nSM\r\n\r\n&quot;.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3A-2ASETTINGS-FRAME-2A-20VARIABLE-29"></a>
<a id="MINI-HTTP2:*SETTINGS-FRAME*%20VARIABLE"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[variable]</span> <span class="reference-object"><a href="#MINI-HTTP2:*SETTINGS-FRAME*%20VARIABLE" >*SETTINGS-FRAME*</a></span></span> <span class="locative-args">#(0 0 0 4 0 0 0 0 0)</span></span></p>

<p>After client preface, both client and server send their settings frame
(<code>*SETTINGS-FRAME*</code>). The frame here is empty settings frame.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3A-2AACK-FRAME-2A-20VARIABLE-29"></a>
<a id="MINI-HTTP2:*ACK-FRAME*%20VARIABLE"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[variable]</span> <span class="reference-object"><a href="#MINI-HTTP2:*ACK-FRAME*%20VARIABLE" >*ACK-FRAME*</a></span></span> <span class="locative-args">#(0 0 0 4 1 0 0 0 0)</span></span></p>

<p>Settings frame should be acknowledged by sending <code>*ACK-FRAME*</code> (type+flag)</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3ASTREAM-ID-20TYPE-29"></a>
<a id="MINI-HTTP2:STREAM-ID%20TYPE"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[type]</span> <span class="reference-object"><a href="#MINI-HTTP2:STREAM-ID%20TYPE" >STREAM-ID</a></span></span></span></p>

<p>Client sends HTTP2 requests as a headers (and possibly data) frame, with last
packet having END-OF-HEADERS flag
particular stream. Each stream is a 23 bit integer.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3A-2ADATA-FRAME-2A-20VARIABLE-29"></a>
<a id="MINI-HTTP2:*DATA-FRAME*%20VARIABLE"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[variable]</span> <span class="reference-object"><a href="#MINI-HTTP2:*DATA-FRAME*%20VARIABLE" >*DATA-FRAME*</a></span></span> <span class="locative-args">#(0 0 12 0 1 0 0 0 0 72 101 108 108 111 32 87 111 114 108 100 10)</span></span></p>

<p>Server replies to header frame with header and data frames with same stream
ID. The data frame here is a data frame with zero stream ID (to be patched
before sending) and payload short ASCII text from <em>result-text</em>.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3A-2BGOAWAY-FRAME-TYPE-2B-20MGL-PAX-3ACONSTANT-29"></a>
<a id="MINI-HTTP2:+GOAWAY-FRAME-TYPE+%20MGL-PAX:CONSTANT"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[constant]</span> <span class="reference-object"><a href="#MINI-HTTP2:+GOAWAY-FRAME-TYPE+%20MGL-PAX:CONSTANT" >+GOAWAY-FRAME-TYPE+</a></span></span> <span class="locative-args">7</span></span></p>

<p>When client is done (or after an error) it sends goaway frame, and both client
and server terminate the connection socket. This is kind of courtesy, and any
side should be ready for the other side terminating connection without goaway
frame.</p>

<p>Server can send goaway frame as well, but our servers do not.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3AGET-FRAME-SIZE-20FUNCTION-29"></a>
<a id="MINI-HTTP2:GET-FRAME-SIZE%20FUNCTION"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:GET-FRAME-SIZE%20FUNCTION" >GET-FRAME-SIZE</a></span></span> <span class="locative-args">HEADER</span></span></p>

<p>Get frame size of a frame from frame header.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3AGET-STREAM-ID-20FUNCTION-29"></a>
<a id="MINI-HTTP2:GET-STREAM-ID%20FUNCTION"></a></p>
<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:GET-STREAM-ID%20FUNCTION" >GET-STREAM-ID</a></span></span> <span class="locative-args">HEADER</span></span></li>
</ul>
<p><a id="x-28MINI-HTTP2-3AGET-FRAME-TYPE-20FUNCTION-29"></a>
<a id="MINI-HTTP2:GET-FRAME-TYPE%20FUNCTION"></a></p>
<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:GET-FRAME-TYPE%20FUNCTION" >GET-FRAME-TYPE</a></span></span> <span class="locative-args">HEADER</span></span></li>
</ul>
<p><a id="x-28MINI-HTTP2-3AGET-FRAME-FLAGS-20FUNCTION-29"></a>
<a id="MINI-HTTP2:GET-FRAME-FLAGS%20FUNCTION"></a></p>
<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:GET-FRAME-FLAGS%20FUNCTION" >GET-FRAME-FLAGS</a></span></span> <span class="locative-args">HEADER</span></span></li>
</ul>
<p><a id="x-28MINI-HTTP2-3AGET-STREAM-ID-IF-ENDS-20FUNCTION-29"></a>
<a id="MINI-HTTP2:GET-STREAM-ID-IF-ENDS%20FUNCTION"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:GET-STREAM-ID-IF-ENDS%20FUNCTION" >GET-STREAM-ID-IF-ENDS</a></span></span> <span class="locative-args">HEADER</span></span></p>

<p>Stream id when header closes the stream on client side.</p></li>
</ul>
<p><a id="x-28MINI-HTTP2-3ABUFFER-WITH-CHANGED-STREAM-20FUNCTION-29"></a>
<a id="MINI-HTTP2:BUFFER-WITH-CHANGED-STREAM%20FUNCTION"></a></p>
<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type">[function]</span> <span class="reference-object"><a href="#MINI-HTTP2:BUFFER-WITH-CHANGED-STREAM%20FUNCTION" >BUFFER-WITH-CHANGED-STREAM</a></span></span> <span class="locative-args">BUF STREAM-ID</span></span></p>

<p>Change stream id of a frame in <code>BUF</code> to <code>STREAM-ID</code>.</p></li>
</ul>
  </div>
</div>
<script>$('#page-toc').toc({'selectors': 'h1,h2,h3,h4'});</script>
</body>
</html>
